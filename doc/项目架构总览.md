# FileHub 项目架构总览

## 一、项目概述

FileHub 是一个基于 C++ 和 muduo 网络库开发的云文件存储与共享系统，支持文件上传、下载、分享、转存等功能。系统采用 Reactor 网络模型，使用 MySQL 存储元数据，Redis 作为缓存层，FastDFS 作为分布式文件存储系统。

---

## 二、目录结构分析

### 2.1 顶层目录

```
filehub-cloud/
├── application/          # 应用层代码
│   └── filehub/         # 核心业务代码
├── muduo/               # muduo 网络库（第三方依赖）
├── sql/                 # 数据库建表脚本
├── front/               # 前端代码（暂无）
├── client_test/         # 客户端测试代码
├── wrk_test/            # 压力测试脚本
└── build/               # 构建目录
```

### 2.2 核心模块目录（application/filehub/）

```
filehub/
├── main.cc                    # 程序入口，服务器启动
├── http_conn.h/cc            # HTTP 连接封装，路由分发
├── http_parser.h/cc           # HTTP 协议解析器（底层）
├── http_parser_wrapper.h/cc   # HTTP 解析器封装
├── tc_http_server.conf        # 配置文件
│
├── api/                       # 业务 API 层
│   ├── api_common.h/cc        # 公共工具函数
│   ├── api_register.h/cc      # 用户注册
│   ├── api_login.h/cc         # 用户登录
│   ├── api_upload.h/cc       # 文件上传
│   ├── api_myfiles.h/cc       # 我的文件列表
│   ├── api_sharefiles.h/cc    # 共享文件列表
│   ├── api_dealfile.h/cc      # 文件操作（分享/删除/下载）
│   ├── api_deal_sharefile.h/cc # 共享文件操作（取消分享/转存/下载）
│   ├── api_sharepicture.h/cc  # 图片分享
│   └── api_md5.h/cc          # MD5 计算
│
├── mysql/                     # MySQL 数据库连接池
│   ├── db_pool.h/cc           # 连接池实现
│
├── redis/                     # Redis 缓存连接池
│   ├── cache_pool.h/cc       # 连接池实现
│   └── hiredis.*              # hiredis 客户端库
│
└── base/                      # 基础工具模块
    ├── config_file_reader.h/cc # 配置文件读取
    └── util.h/cc              # 工具函数
```

---

## 三、系统架构设计

### 3.1 网络模型架构

系统采用 **muduo 的 Reactor 多线程模型**，具体架构如下：

```
┌─────────────────────────────────────────────────────────┐
│                    Main Thread (主线程)                  │
│  ┌──────────────────────────────────────────────────┐   │
│  │  EventLoop (主 Reactor)                          │   │
│  │  - 监听新连接 (Acceptor)                          │   │
│  │  - 分发连接给 SubReactor                          │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌──────▼──────┐ ┌──────▼──────┐
│ SubReactor 1 │ │ SubReactor 2│ │ SubReactor N│
│ (IO Thread)  │ │ (IO Thread) │ │ (IO Thread) │
│              │ │             │ │             │
│ EventLoop    │ │ EventLoop   │ │ EventLoop   │
│ - 处理连接    │ │ - 处理连接   │ │ - 处理连接  │
│ - 数据收发    │ │ - 数据收发   │ │ - 数据收发  │
└───────┬──────┘ └──────┬──────┘ └──────┬──────┘
        │               │               │
        └───────────────┼───────────────┘
                        │
        ┌───────────────▼───────────────┐
        │    ThreadPool (业务线程池)     │
        │  - 处理 HTTP 请求解析          │
        │  - 执行业务逻辑               │
        │  - 数据库/缓存操作            │
        └──────────────────────────────┘
```

**关键组件说明：**

1. **主线程 (Main Thread)**
   - 运行主 EventLoop
   - 负责监听新连接（通过 `Acceptor`）
   - 将新连接分发给 SubReactor（通过 `EventLoopThreadPool`）

2. **IO 线程 (SubReactor)**
   - 数量由配置 `num_event_loops` 控制（默认 4）
   - 每个 IO 线程运行独立的 EventLoop
   - 负责连接的建立/断开、数据收发（非阻塞 I/O）

3. **业务线程池 (ThreadPool)**
   - 数量由配置 `num_threads` 控制（默认 64）
   - 处理 HTTP 请求解析和业务逻辑
   - 避免阻塞 IO 线程

### 3.2 数据流架构

```
客户端 HTTP 请求
    │
    ▼
┌─────────────────────────────────────────┐
│  TcpServer (muduo)                      │
│  - 接收 TCP 连接                        │
│  - 数据写入 Buffer                      │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│  HttpServer::onMessage()                │
│  - 从 Buffer 读取数据                    │
│  - 分发到业务线程池或直接处理             │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│  CHttpConn::OnRead()                    │
│  - HTTP 协议解析 (http_parser_wrapper)   │
│  - 提取 URL 和 Body                      │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│  路由分发 (http_conn.cc)                 │
│  - /api/reg      → _HandleRegisterRequest│
│  - /api/login    → _HandleLoginRequest   │
│  - /api/upload   → _HandleUploadRequest  │
│  - /api/myfiles  → _HandleMyFilesRequest │
│  - ...                                  │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│  API 业务层 (api/*.cc)                  │
│  - 参数解析 (JSON)                      │
│  - Token 验证                           │
│  - 业务逻辑处理                          │
└─────────────────────────────────────────┘
    │
    ├──────────────────┬──────────────────┐
    ▼                  ▼                  ▼
┌──────────┐    ┌──────────┐    ┌──────────┐
│  MySQL   │    │  Redis   │    │ FastDFS  │
│ 连接池   │    │ 连接池   │    │ 文件存储 │
└──────────┘    └──────────┘    └──────────┘
    │                  │                  │
    ▼                  ▼                  ▼
┌──────────┐    ┌──────────┐    ┌──────────┐
│  MySQL   │    │  Redis   │    │ FastDFS  │
│ 数据库   │     │ 缓存     │    │ Storage  │
└──────────┘    └──────────┘    └──────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│  构造 HTTP 响应                         │
│  - JSON 序列化                           │
│  - 发送响应 (tcp_conn_->send())         │
└─────────────────────────────────────────┘
    │
    ▼
客户端接收响应
```

---

## 四、核心模块详解

### 4.1 网络收包和解析模块

**职责：** 接收 TCP 数据，解析 HTTP 协议，提取请求信息

**关键文件：**
- `main.cc` - `HttpServer::onMessage()`：接收数据回调
- `http_conn.cc` - `CHttpConn::OnRead()`：HTTP 解析入口
- `http_parser_wrapper.cc` - `CHttpParserWrapper::ParseHttpContent()`：HTTP 协议解析

**流程：**
1. `TcpServer` 收到数据，触发 `onMessage` 回调
2. 根据是否启用线程池，选择在 IO 线程或业务线程处理
3. `CHttpConn::OnRead()` 调用 `http_parser_wrapper` 解析 HTTP
4. 解析完成后提取 URL 和 Body，进行路由分发

### 4.2 业务逻辑模块

**职责：** 处理各种业务请求，包括用户管理、文件管理等

**关键文件：**
- `http_conn.cc` - 路由分发和请求处理入口
- `api/*.cc` - 各业务 API 实现

**API 列表：**

| API 路径 | 处理函数 | 功能说明 |
|---------|---------|---------|
| `/api/reg` | `_HandleRegisterRequest` | 用户注册 |
| `/api/login` | `_HandleLoginRequest` | 用户登录 |
| `/api/md5` | `_HandleMd5Request` | 计算文件 MD5 |
| `/api/upload` | `_HandleUploadRequest` | 文件上传 |
| `/api/myfiles` | `_HandleMyFilesRequest` | 获取我的文件列表 |
| `/api/sharefiles` | `_HandleSharefilesRequest` | 获取共享文件列表 |
| `/api/dealfile?cmd=share` | `_HandleDealfileRequest` | 分享文件 |
| `/api/dealfile?cmd=del` | `_HandleDealfileRequest` | 删除文件 |
| `/api/dealsharefile?cmd=cancel` | `_HandleDealsharefileRequest` | 取消分享 |
| `/api/dealsharefile?cmd=save` | `_HandleDealsharefileRequest` | 转存文件 |
| `/api/sharepic` | `_HandleSharepictureRequest` | 图片分享 |

**路由分发机制：**
- 使用 `strncmp` 进行 URL 前缀匹配（可优化为 hash map）
- 每个 API 独立处理函数，职责清晰

### 4.3 MySQL 访问模块

**职责：** 封装 MySQL 连接池，提供数据库操作接口

**关键文件：**
- `mysql/db_pool.h/cc`

**核心类：**

1. **CDBManager**（单例）
   - 管理多个连接池（支持主从）
   - 从配置文件读取连接池配置
   - 提供 `GetDBConn()` 和 `RelDBConn()` 接口

2. **CDBPool**（连接池）
   - 维护空闲连接列表（`free_list_`）
   - 支持动态扩容（最大连接数限制）
   - 使用 `mutex` + `condition_variable` 实现线程安全
   - 支持超时等待获取连接

3. **CDBConn**（数据库连接）
   - 封装 MySQL C API
   - 提供 `ExecuteQuery()`、`ExecuteUpdate()`、`ExecuteCreate()` 等方法
   - 自动 `mysql_ping()` 保持连接活跃

4. **CResultSet**（结果集）
   - 封装查询结果
   - 提供 `GetInt()`、`GetString()` 等方法

5. **AutoRelDBCon**（RAII 包装）
   - 自动归还连接，避免泄漏

**连接池配置：**
- 主库：`filehub_master`（写操作）
- 从库：`filehub_slave`（读操作，当前未使用）
- 最大连接数：128（可配置）

### 4.4 Redis 访问模块

**职责：** 封装 Redis 连接池，提供缓存操作接口

**关键文件：**
- `redis/cache_pool.h/cc`

**核心类：**

1. **CacheManager**（单例）
   - 管理多个连接池（支持不同 Redis 实例）
   - 从配置文件读取连接池配置

2. **CachePool**（连接池）
   - 类似 MySQL 连接池设计
   - 支持动态扩容和超时等待

3. **CacheConn**（Redis 连接）
   - 封装 hiredis 客户端
   - 提供丰富的 Redis 操作：
     - String: `Get()`, `Set()`, `SetEx()`, `MGet()`, `Incr()`
     - Hash: `Hget()`, `Hset()`, `HgetAll()`, `Hmset()`
     - List: `Lpush()`, `Rpush()`, `Lrange()`
     - ZSet: `ZsetAdd()`, `ZsetIncr()`, `ZsetZrevrange()`

**Redis 使用场景：**
- **Token 缓存**：`token` 连接池（db=0），存储用户登录 token
- **排行榜缓存**：`ranking_list` 连接池（db=1），存储共享文件排行榜（ZSet）
- **文件信息缓存**：`FILE_NAME_HASH`，存储 fileid -> filename 映射

### 4.5 文件上传完整调用链

```
客户端上传请求 (multipart/form-data)
    │
    ▼
CHttpConn::_HandleUploadRequest()
    │
    ▼
ApiUpload() [api_upload.cc]
    │
    ├─ 1. 解析 multipart 数据
    │   - 提取 file_name, file_path, file_md5, file_size, user
    │
    ├─ 2. 重命名临时文件（添加后缀）
    │   - rename(file_path, new_file_path)
    │
    ├─ 3. 上传到 FastDFS
    │   └─ uploadFileToFastDfs()
    │       - fork() 创建子进程
    │       - execlp("fdfs_upload_file", ...)
    │       - 通过管道读取 fileid
    │
    ├─ 4. 获取文件完整 URL
    │   └─ getFullUrlByFileid()
    │       - fork() 创建子进程
    │       - execlp("fdfs_file_info", ...)
    │       - 解析输出获取 storage IP
    │       - 拼接 URL: http://storage_ip/fileid
    │
    ├─ 5. 存储文件信息到数据库
    │   └─ storeFileinfo()
    │       ├─ 获取数据库连接（连接池）
    │       ├─ 获取文件锁（FileInfoLock）
    │       ├─ 插入 file_info 表（如果已存在则更新 count）
    │       └─ 插入 user_file_list 表
    │
    ├─ 6. 删除本地临时文件
    │   - unlink(new_file_path)
    │
    └─ 7. 返回响应（JSON）
```

**关键数据结构：**

- **file_info 表**：存储文件元信息（md5, file_id, url, size, type, count）
- **user_file_list 表**：存储用户文件列表（user, md5, create_time, file_name, shared_status, pv）

### 4.6 文件共享流程

**分享文件：** (`api_dealfile.cc::handleShareFile()`)

```
1. 检查 Redis ZSet 中是否已存在（FILE_PUBLIC_ZSET）
   - 如果存在，返回"别人已分享"

2. 检查 MySQL share_file_list 表
   - 如果存在，同步到 Redis，返回"别人已分享"

3. 更新 user_file_list.shared_status = 1

4. 插入 share_file_list 记录

5. 写入 Redis：
   - ZsetAdd(FILE_PUBLIC_ZSET, 0, fileid)
   - Hset(FILE_NAME_HASH, fileid, filename)
```

**取消分享：** (`api_deal_sharefile.cc::handleCancelShareFile()`)

```
1. 更新 user_file_list.shared_status = 0
2. 删除 share_file_list 记录
3. 从 Redis ZSet 删除（ZsetZrem）
4. 从 Redis Hash 删除（Hdel）
```

**转存文件：** (`api_deal_sharefile.cc::handleSaveFile()`)

```
1. 检查用户是否已有该文件
2. 插入 user_file_list 记录
3. 更新 file_info.count += 1
```

### 4.7 配置加载流程

**配置文件：** `tc_http_server.conf`

**加载流程：**

```
main()
    │
    ├─ 1. 读取配置文件路径（命令行参数或默认）
    │
    ├─ 2. CConfigFileReader 解析配置文件
    │   - 读取 key=value 格式
    │   - 存储到 map<string, string>
    │
    ├─ 3. 初始化日志级别
    │   - Logger::setLogLevel()
    │
    ├─ 4. 初始化 Redis 连接池
    │   - CacheManager::SetConfPath()
    │   - CacheManager::getInstance()->Init()
    │   - 读取 CacheInstances 配置
    │
    ├─ 5. 初始化 MySQL 连接池
    │   - CDBManager::SetConfPath()
    │   - CDBManager::getInstance()->Init()
    │   - 读取 DBInstances 配置
    │
    ├─ 6. 初始化 FastDFS 配置
    │   - ApiUploadInit()
    │
    └─ 7. 创建 HttpServer 并启动
        - 读取 num_event_loops, num_threads, timeout_ms
```

**关键配置项：**

```ini
# 网络配置
http_bind_ip=0.0.0.0
http_bind_port=8081
num_event_loops=4      # SubReactor 数量
num_threads=64         # 业务线程池大小
timeout_ms=10          # epoll 超时时间

# 日志配置
log_level=4            # ERROR 级别

# FastDFS 配置
dfs_path_client=/etc/fdfs/client.conf
storage_web_server_ip=192.168.253.100
storage_web_server_port=80

# MySQL 配置
DBInstances=filehub_master,filehub_slave
filehub_master_host=localhost
filehub_master_port=3306
filehub_master_maxconncnt=128

# Redis 配置
CacheInstances=token,ranking_list
token_host=127.0.0.1
token_port=6379
token_maxconncnt=128
```

### 4.8 日志系统

**使用 muduo 的 Logging 模块**

- **日志级别：** TRACE(0) < DEBUG(1) < INFO(2) < WARN(3) < ERROR(4) < FATAL(5)
- **默认级别：** 从配置文件读取，默认 ERROR
- **日志输出：** 支持异步日志（AsyncLogging）
- **使用方式：** `LOG_INFO << "message";`

### 4.9 异常处理和错误传播机制

**错误处理策略：**

1. **数据库操作失败**
   - 返回错误码，记录日志
   - 使用 `AUTO_REL_DBCONN` 确保连接归还

2. **Redis 操作失败**
   - 记录日志，继续执行（缓存不可用不应阻塞主流程）
   - 使用 `AUTO_REL_CACHECONN` 确保连接归还

3. **FastDFS 操作失败**
   - 记录日志，返回错误响应
   - 清理已创建的资源（如临时文件）

4. **HTTP 解析失败**
   - 返回 400 Bad Request

5. **Token 验证失败**
   - 返回 `HTTP_RESP_TOKEN_ERR` (code=4)

**错误码定义：** (`api_common.h`)

```cpp
#define HTTP_RESP_OK 0              // 成功
#define HTTP_RESP_FAIL 1             // 失败
#define HTTP_RESP_USER_EXIST 2       // 用户已存在
#define HTTP_RESP_DEALFILE_EXIST 3   // 别人已分享此文件
#define HTTP_RESP_TOKEN_ERR 4        // Token 验证失败
#define HTTP_RESP_FILE_EXIST 5       // 个人已存储该文件
```

---

## 五、跨模块依赖关系

```
main.cc
    │
    ├─→ HttpServer (自定义)
    │       ├─→ TcpServer (muduo)
    │       ├─→ EventLoop (muduo)
    │       ├─→ ThreadPool (muduo)
    │       └─→ CHttpConn
    │
    ├─→ CConfigFileReader
    │
    ├─→ CacheManager (单例)
    │       └─→ CachePool → CacheConn → hiredis
    │
    ├─→ CDBManager (单例)
    │       └─→ CDBPool → CDBConn → mysqlclient
    │
    └─→ ApiUploadInit

CHttpConn
    │
    ├─→ CHttpParserWrapper
    │       └─→ http_parser (第三方)
    │
    └─→ API 层 (api/*.cc)
            ├─→ api_common.h
            │       ├─→ db_pool.h
            │       ├─→ cache_pool.h
            │       └─→ json/json.h
            │
            ├─→ CDBManager (获取数据库连接)
            ├─→ CacheManager (获取缓存连接)
            └─→ FastDFS (通过 fork+execlp)
```

**依赖层次：**

1. **网络层**：muduo 库（TcpServer, EventLoop, Buffer）
2. **协议层**：http_parser（HTTP 解析）
3. **业务层**：api/*.cc（业务逻辑）
4. **数据层**：MySQL 连接池、Redis 连接池
5. **存储层**：FastDFS（外部进程）

---

## 六、关键全局资源

### 6.1 连接池资源

1. **MySQL 连接池**
   - 主库：`filehub_master`（最大 128 连接）
   - 从库：`filehub_slave`（最大 128 连接，当前未使用）

2. **Redis 连接池**
   - `token`：Token 缓存（db=0，最大 128 连接）
   - `ranking_list`：排行榜缓存（db=1，最大 128 连接）

### 6.2 线程资源

- **主线程**：1 个（运行主 EventLoop）
- **IO 线程**：4 个（SubReactor，可配置）
- **业务线程**：64 个（ThreadPool，可配置）

### 6.3 文件描述符（FD）

- **监听 socket**：1 个（主线程）
- **连接 socket**：动态（每个 HTTP 连接一个）
- **管道 FD**：FastDFS 操作时临时创建（fork 进程通信）

### 6.4 全局单例

- `CDBManager::s_db_manager`：数据库管理器
- `CacheManager::s_cache_manager`：缓存管理器
- `FileInfoLock::GetInstance()`：文件信息锁（单例）

### 6.5 全局映射表

- `s_http_map`：`map<uint32_t, CHttpConnPtr>`（连接 UUID -> HTTP 连接对象）

---

## 七、数据流说明

### 7.1 请求处理数据流

```
客户端 → TCP 连接建立
      → TcpServer::onConnection() [创建 CHttpConn]
      → TcpServer::onMessage() [接收数据到 Buffer]
      → HttpServer::onMessage() [分发到线程池]
      → CHttpConn::OnRead() [解析 HTTP]
      → 路由分发 [根据 URL]
      → API 处理函数 [业务逻辑]
      → 数据库/缓存操作
      → 构造响应
      → tcp_conn_->send() [发送响应]
      → 客户端接收
```

### 7.2 文件上传数据流

```
客户端 multipart/form-data
      → 解析 boundary、file_name、file_path、file_md5、file_size、user
      → 重命名临时文件（添加后缀）
      → fork() + execlp("fdfs_upload_file") [上传到 FastDFS]
      → 获取 fileid
      → fork() + execlp("fdfs_file_info") [获取 storage IP]
      → 拼接完整 URL
      → 获取文件锁（FileInfoLock）
      → 插入/更新 file_info 表
      → 插入 user_file_list 表
      → 删除临时文件
      → 返回 JSON 响应
```

### 7.3 文件共享数据流

```
分享请求
      → Token 验证
      → 检查 Redis ZSet（FILE_PUBLIC_ZSET）
      → 检查 MySQL share_file_list 表
      → 更新 user_file_list.shared_status = 1
      → 插入 share_file_list 记录
      → 写入 Redis（ZSet + Hash）
      → 返回响应

取消分享
      → 更新 user_file_list.shared_status = 0
      → 删除 share_file_list 记录
      → 从 Redis 删除（ZSet + Hash）
      → 返回响应
```

---

## 八、调用链说明

### 8.1 文件上传调用链

```
main()
  └─→ HttpServer::start()
        └─→ TcpServer::start()
              └─→ EventLoop::loop()
                    └─→ onMessage()
                          └─→ CHttpConn::OnRead()
                                └─→ CHttpParserWrapper::ParseHttpContent()
                                      └─→ _HandleUploadRequest()
                                            └─→ ApiUpload()
                                                  ├─→ uploadFileToFastDfs()
                                                  │     └─→ fork() + execlp("fdfs_upload_file")
                                                  ├─→ getFullUrlByFileid()
                                                  │     └─→ fork() + execlp("fdfs_file_info")
                                                  └─→ storeFileinfo()
                                                        ├─→ CDBManager::GetDBConn()
                                                        ├─→ FileInfoLock::TryLockFor()
                                                        ├─→ db_conn->ExecuteCreate()
                                                        └─→ db_conn->ExecuteCreate()
```

### 8.2 文件分享调用链

```
_HandleDealfileRequest()
  └─→ ApiDealfile()
        └─→ handleShareFile()
              ├─→ CacheManager::GetCacheConn("ranking_list")
              ├─→ cache_conn->ZsetExist()
              ├─→ CDBManager::GetDBConn("filehub_master")
              ├─→ db_conn->ExecuteQuery()
              ├─→ db_conn->ExecuteUpdate()
              ├─→ db_conn->ExecuteCreate()
              └─→ cache_conn->ZsetAdd() + Hset()
```

### 8.3 用户登录调用链

```
_HandleLoginRequest()
  └─→ ApiUserLogin()
        ├─→ CDBManager::GetDBConn()
        ├─→ db_conn->ExecuteQuery()
        ├─→ 密码验证（MD5）
        ├─→ CacheManager::GetCacheConn("token")
        └─→ cache_conn->SetEx() [存储 token]
```

---

## 九、架构风险点分析

### 9.1 高并发下的潜在问题

#### 1. **连接管理问题**
- **风险**：`s_http_map` 使用全局 mutex，高并发下可能成为瓶颈
- **位置**：`main.cc:21`, `main.cc:54-61`, `main.cc:68-70`
- **影响**：连接建立/断开时锁竞争

#### 2. **路由分发效率**
- **风险**：使用 `strncmp` 逐一遍历 URL，效率低
- **位置**：`http_conn.cc:64-98`
- **建议**：使用 hash map 或 trie 树优化

#### 3. **FastDFS 操作阻塞**
- **风险**：`fork() + execlp()` 是阻塞操作，会占用业务线程
- **位置**：`api_upload.cc:uploadFileToFastDfs()`, `getFullUrlByFileid()`
- **影响**：高并发上传时线程池可能耗尽
- **建议**：使用异步方式或独立线程池处理

#### 4. **文件锁竞争**
- **风险**：`FileInfoLock` 是全局单例锁，所有文件上传都会竞争
- **位置**：`api_common.h:FileInfoLock`, `api_upload.cc:236`
- **影响**：高并发上传时可能超时
- **建议**：使用分段锁（按 md5 分片）

#### 5. **连接池耗尽**
- **风险**：如果业务线程长时间持有连接，可能导致连接池耗尽
- **位置**：`db_pool.cc:GetDBConn()`, `cache_pool.cc:GetCacheConn()`
- **缓解**：使用 `AUTO_REL_DBCONN` 和 `AUTO_REL_CACHECONN` 自动归还

#### 6. **临时文件清理**
- **风险**：如果进程异常退出，临时文件可能残留
- **位置**：`api_upload.cc:460-463`
- **建议**：增加定时清理任务

#### 7. **数据库连接泄漏**
- **风险**：如果异常路径未使用 RAII，可能泄漏连接
- **缓解**：已使用 `AUTO_REL_DBCONN`，但需确保所有路径都覆盖

#### 8. **Redis 缓存一致性**
- **风险**：Redis 和 MySQL 数据可能不一致（如 Redis 写入失败但 MySQL 成功）
- **位置**：`api_dealfile.cc:handleShareFile()`
- **建议**：增加重试机制或使用事务

#### 9. **内存泄漏风险**
- **风险**：`new char[]` 后如果异常可能泄漏
- **位置**：`http_conn.cc:110`, `http_conn.cc:124` 等
- **缓解**：使用 `delete[]`，但建议使用智能指针

#### 10. **线程池配置不当**
- **风险**：如果 `num_threads=0`，所有业务在 IO 线程执行，可能阻塞网络 I/O
- **位置**：`main.cc:72-76`
- **建议**：生产环境必须启用线程池

### 9.2 性能瓶颈点

1. **全局锁竞争**：`s_http_map` 的 mutex
2. **文件锁竞争**：`FileInfoLock` 全局锁
3. **FastDFS 阻塞**：fork 进程操作
4. **数据库连接池**：连接数限制（128）
5. **Redis 连接池**：连接数限制（128）

### 9.3 可靠性问题

1. **FastDFS 操作失败处理**：部分失败场景可能未清理资源
2. **数据库事务**：部分操作未使用事务，可能导致数据不一致
3. **异常处理**：部分异常路径可能未正确释放资源

---

## 十、总结

### 10.1 架构特点

1. **网络模型**：Reactor 多线程模型，IO 线程与业务线程分离
2. **连接池**：MySQL 和 Redis 均使用连接池，支持动态扩容
3. **存储架构**：MySQL（元数据）+ Redis（缓存）+ FastDFS（文件存储）
4. **路由机制**：基于 URL 前缀匹配，简单直接
5. **错误处理**：使用错误码和日志记录

### 10.2 优势

- 网络层与业务层解耦，职责清晰
- 连接池设计合理，支持高并发
- 使用 RAII 自动管理资源
- 支持主从数据库配置（扩展性）

### 10.3 改进建议

1. **路由优化**：使用 hash map 替代 `strncmp`
2. **异步化**：FastDFS 操作改为异步
3. **锁优化**：文件锁改为分段锁
4. **事务支持**：关键操作使用数据库事务
5. **监控告警**：增加连接池监控、错误率监控
6. **代码优化**：使用智能指针替代裸指针

---

**文档版本：** v1.0  
**最后更新：** 2025年  
**维护者：** FileHub 开发团队

